for (d in 1:nyears){							### replace missing dates with mean for each survey round in each year
ACT[is.na(ACT[,1,d]),1,d]<-mean(ACT[,1,d], na.rm=T)
ACT[is.na(ACT[,2,d]),2,d]<-mean(ACT[,2,d], na.rm=T)
ACT[is.na(ACT[,3,d]),3,d]<-mean(ACT[,3,d], na.rm=T)
time[is.na(time[,1,d]),1,d]<-mean(time[,1,d], na.rm=T)
time[is.na(time[,2,d]),2,d]<-mean(time[,2,d], na.rm=T)
time[is.na(time[,3,d]),3,d]<-mean(time[,3,d], na.rm=T)
wind[is.na(wind[,1,d]),1,d]<-0
wind[is.na(wind[,2,d]),2,d]<-0
wind[is.na(wind[,3,d]),3,d]<-0
}
scale(rain$rain)
rain<-fread("data/MontserratRain2005_2023.csv",fill=TRUE) %>%
dplyr::filter(Variable=="RainMM") %>%
dplyr::filter(YEAR %in% seq(2010,2024,1)) %>%
dplyr::select(-Variable,-Total) %>%
gather(key="Month", value="mm",-YEAR) %>%
dplyr::filter(Month %in% c('JAN','FEB','MAR')) %>%
group_by(YEAR) %>%
summarise(rain=sum(mm)) %>%
mutate(rain=scale(rain))
rain
rain<-fread("data/MontserratRain2005_2023.csv",fill=TRUE) %>%
dplyr::filter(Variable=="RainMM") %>%
dplyr::filter(YEAR %in% seq(2010,2024,1)) %>%
dplyr::select(-Variable,-Total) %>%
gather(key="Month", value="mm",-YEAR) %>%
dplyr::filter(Month %in% c('JAN','FEB','MAR')) %>%
group_by(YEAR) %>%
summarise(rain=sum(mm)) %>%
mutate(rain=scale(rain)[,1])
rain
load("data/MONTSERRAT_ANNUAL_DATA_INPUT2024.RData")
#load("S:\\ConSci\\DptShare\\SteffenOppel\\RSPB\\Montserrat\\Analysis\\Population_status_assessment\\AnnualMonitoring\\MONTSERRAT_ANNUAL_DATA_INPUT2023.RData")
fullnames<-c("Montserrat Oriole", "Forest Thrush", "Bridled Quail-Dove", "Brown Trembler",
"Antillean Crested Hummingbird","Purple-throated Carib",
"Pearly-eyed Thrasher","Green-throated Carib","Scaly-breasted Thrasher","Scaly-naped Pigeon",
"Caribbean Elaenia","Bananaquit")
### summarise rainfall from Jan to March, productivity from PREVIOUS year will affect count in current year
rain<-fread("data/MontserratRain2005_2023.csv",fill=TRUE) %>%
dplyr::filter(Variable=="RainMM") %>%
dplyr::filter(YEAR %in% seq(2010,2024,1)) %>%
dplyr::select(-Variable,-Total) %>%
gather(key="Month", value="mm",-YEAR) %>%
dplyr::filter(Month %in% c('JAN','FEB','MAR')) %>%
group_by(YEAR) %>%
summarise(rain=sum(mm)) %>%
mutate(rain=scale(rain)[,1])
###############################################################################
############## CREATE SITE COVARIATE DATA INPUT MATRIX   ######################
###############################################################################
nsites<-length(unique(siteCov$Point))
siteCov<-siteCov %>% arrange(Point) %>%
dplyr::select(Point,treeheight,Elevation,Canopy_cover,ridge) %>%
mutate(tree=scale(treeheight)[,1], elev=scale(Elevation)[,1],canopy=scale(Canopy_cover)[,1])
siteCov
###############################################################################
############## CREATE OBSERVATION COVARIATE DATA INPUT MATRIX   ###############
###############################################################################
SURVEYDATA<-SURVEYDATA %>%
arrange(Point,Year,Count) %>%
mutate(time=scale(time),Day=scale(Day))
## SORT THE TABLE SO IT HAS THE SAME ORDER AS THE BIRD DATA
obsCov<-obsCov %>%
arrange(Point,Year,Count)
### only needs standardisation if measured in mm, not as 0/1 variable
#meant<-mean(SURVEYDATA$rain, na.rm = TRUE)
#sdt<-sd(SURVEYDATA$rain, na.rm = TRUE)
#SURVEYDATA$rain<-(SURVEYDATA$rain-meant)/sdt
### create array for each covariate
ridge<-array(NA, dim=c(nsites,3,nyears))
wind<-array(NA, dim=c(nsites,3,nyears))
time<-array(NA, dim=c(nsites,3,nyears))
ACT<-array(NA, dim=c(nsites,3,nyears))				## REPLACED ON 2 MAY WITH RAINFALL AMOUNT
### fill in array for each covariate
for (y in 2011:YEAR){
obsC<-subset(SURVEYDATA, Year==y)
y<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
x<-obsC %>% dplyr::select(Point, Count, time) %>% tidyr::spread(key=Count, value=time) %>% dplyr::arrange(Point)
time[,,y]<-as.matrix(x[,2:4])
x<-obsC %>% dplyr::select(Point, Count, wind) %>% tidyr::spread(key=Count, value=wind) %>% dplyr::arrange(Point)
wind[,,y]<-as.matrix(x[,2:4])
x<-obsC %>% dplyr::select(Point, Count, ACT) %>% tidyr::spread(key=Count, value=ACT) %>% dplyr::arrange(Point)
ACT[,,y]<-as.matrix(x[,2:4])
ridge[,,y]<-matrix(rep(siteCov$ridge,3), ncol=3)		### site-level obs covariates are constant across years and counts
}
###############################################################################
####   REPLACE ALL NA IN COVARIATES otherwise "undefined node" error    #######
###############################################################################
for (d in 1:nyears){							### replace missing dates with mean for each survey round in each year
ACT[is.na(ACT[,1,d]),1,d]<-mean(ACT[,1,d], na.rm=T)
ACT[is.na(ACT[,2,d]),2,d]<-mean(ACT[,2,d], na.rm=T)
ACT[is.na(ACT[,3,d]),3,d]<-mean(ACT[,3,d], na.rm=T)
time[is.na(time[,1,d]),1,d]<-mean(time[,1,d], na.rm=T)
time[is.na(time[,2,d]),2,d]<-mean(time[,2,d], na.rm=T)
time[is.na(time[,3,d]),3,d]<-mean(time[,3,d], na.rm=T)
wind[is.na(wind[,1,d]),1,d]<-0
wind[is.na(wind[,2,d]),2,d]<-0
wind[is.na(wind[,3,d]),3,d]<-0
}
# Specify model in NIMBLE format
trend.model<-nimbleCode({
####  Priors ########
loglam~dunif(-5,5)          ##  mean abundance prior
trend~dunif(-10,10)         ##  trend prior
beta.elev~dunif(-5,5)
beta.canopy~dunif(-5,5)
beta.treeheight~dunif(-5,5)
bwind~dunif(-5,5)
btime~dunif(-5,5)
bridge~dunif(-5,5)
bact~dunif(-5,5)
## SITE RANDOM EFFECT ##
for(i in 1:nsite){
lam.site[i]~dnorm(loglam,tau=tau.site)    ## site-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.site<-1/(sigma.site*sigma.site)
sigma.site~dunif(0,10)
## YEAR RANDOM EFFECT FOR ABUNDANCE AND ANNUALLY VARYING DETECTION PROBABILITY ##
for(year in 1:nyear){
p0[year]~dunif(0,1)## detection probability
logitp0[year]<-log(p0[year]/(1-p0[year]))
lam.year[year]~dnorm(trend*primocc[year],tau=tau.year)    ## year-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.lp<-1/(sigma.p*sigma.p)
sigma.p~dunif(0,10)
tau.year<-1/(sigma.year*sigma.year)
sigma.year~dunif(0,10)
######### State and observation models ##############
for(year in 1:nyear){
for(i in 1:nsite){
log(lambda[i,year])<- lam.year[year]+beta.rain*rain[year]+beta.elev*elev[i]+beta.treeheight*treeheight[i]+beta.canopy*canopy[i]+lam.site[i]
N[i,year]~dpois(lambda[i,year])
for(t in 1:nrep){
M[i,t,year]~dbin(p[i,t,year],N[i,year])
p[i,t,year] <- exp(lp[i,t,year])/(1+exp(lp[i,t,year]))
lp[i,t,year] ~ dnorm(mu.lp[i,t,year], tau=tau.lp)
mu.lp[i,t,year]<-logitp0[year] + btime*time[i,t,year]+ bridge*ridge[i,t,year]+ bwind*wind[i,t,year]+ bact*ACT[i,t,year]
}
}
### DERIVED PARAMETER FOR EACH YEAR ###
totalN[year]<-sum(N[1:nsite,year])
anndet[year]<-mean(p[1:nsite,1:nrep,year])
}
# Computation of fit statistic (Bayesian p-value)
# Fit statistic for observed data
# Also, generate replicate data and compute fit stats for them
for(year in 1:nyear){
for(i in 1:nsite){
for(t in 1:nrep){
# Actual data
eval[i,t,year] <-N[i,year]*p[i,t,year] # Expected value
sd.resi[i,t,year]<-sqrt(eval[i,t,year]*(1-p[i,t,year])) +0.5
E[i,t,year]<-(M[i,t,year]-eval[i,t,year])/ sd.resi[i,t,year]
E2[i,t,year] <- pow(E[i,t,year],2)
# Replicate data sets
M.new[i,t,year]~dbin(p[i,t,year],N[i,year])
E.new[i,t,year]<-(M.new[i,t,year]-eval[i,t,year])/sd.resi[i,t,year]
E2.new[i,t,year] <- pow(E.new[i,t,year], 2)
}
}
}
fit <- sum(E2[1:nsite,1:nrep,1:nyear])# Sum up squared residuals for actual data set
fit.new <- sum(E2.new[1:nsite,1:nrep,1:nyear]) # Sum up for replicate data sets
}) ## end of nimble code chunk
inits.trend <- list(N = Nst,
trend=0,
loglam = 0,
sigma.site = 0.5,
sigma.year=0,
sigma.p=0,
beta.canopy=0,
beta.rain=0,
beta.treeheight=0,
beta.elev=0,
bwind=0,
bridge=0,
btime=0,
bact=0,
p0 = 0.3)
# 5.3. Define parameters to be monitored
parameters.trend <- c("trend","totalN","fit", "fit.new","anndet")
bird_s<-subset(COUNTDATA, Species==s)
bird_s<-bird_s[order(bird_s$Point,bird_s$Year, bird_s$Count, decreasing=F),]
### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
bird_s$N[is.na(SURVEYDATA$time)]<-NA
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, Year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=Year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
R = nrow(BIRD.y)
T = ncol(BIRD.y)
nyears = dim(BIRD.y)[3]
trend.constants <- list(nsite=dim(BIRD.y)[1],
nrep=ncol(BIRD.y),
primocc=seq(1:(dim(BIRD.y)[3])),
nyear=dim(BIRD.y)[3],
elev=siteCov$elev,
treeheight=siteCov$tree,
canopy=siteCov$canopy,
rain=rain$rain,
wind=wind,
ridge=ridge,
time=time,
ACT=ACT)
trend.data <- list(M = BIRD.y)
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = trend.productivity,
calculate=TRUE)
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
runif(nyears,0,1)
inits.trend <- list(N = Nst,
trend=0,
loglam = 0,
sigma.site = 2,
sigma.year=0,
sigma.p=0,
beta.canopy=0,
beta.rain=0,
beta.treeheight=0,
beta.elev=0,
bwind=0,
bridge=0,
btime=0,
bact=0,
p0 = runif(nyears,0,1))
# 5.3. Define parameters to be monitored
parameters.trend <- c("trend","totalN","fit", "fit.new","anndet")
# MCMC settings
# number of posterior samples per chain is n.iter - n.burnin
n.iter <- 50000
n.burnin <- 25000
n.chains <- 4
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
model$initializeInfo()
trend.model$initializeInfo()
test$initializeInfo()
Nst
siteCov$elev
siteCov$tree
siteCov$canopy
rain$rain
wind
ridge
time
siteCov
######################################################################################
load("data/MONTSERRAT_ANNUAL_DATA_INPUT2024.RData")
#load("S:\\ConSci\\DptShare\\SteffenOppel\\RSPB\\Montserrat\\Analysis\\Population_status_assessment\\AnnualMonitoring\\MONTSERRAT_ANNUAL_DATA_INPUT2023.RData")
fullnames<-c("Montserrat Oriole", "Forest Thrush", "Bridled Quail-Dove", "Brown Trembler",
"Antillean Crested Hummingbird","Purple-throated Carib",
"Pearly-eyed Thrasher","Green-throated Carib","Scaly-breasted Thrasher","Scaly-naped Pigeon",
"Caribbean Elaenia","Bananaquit")
### summarise rainfall from Jan to March, productivity from PREVIOUS year will affect count in current year
rain<-fread("data/MontserratRain2005_2023.csv",fill=TRUE) %>%
dplyr::filter(Variable=="RainMM") %>%
dplyr::filter(YEAR %in% seq(2010,2024,1)) %>%
dplyr::select(-Variable,-Total) %>%
gather(key="Month", value="mm",-YEAR) %>%
dplyr::filter(Month %in% c('JAN','FEB','MAR')) %>%
group_by(YEAR) %>%
summarise(rain=sum(mm)) %>%
mutate(rain=scale(rain)[,1])
###############################################################################
############## CREATE SITE COVARIATE DATA INPUT MATRIX   ######################
###############################################################################
nsites<-length(unique(siteCov$Point))
siteCov<-siteCov %>% arrange(Point) %>%
dplyr::select(Point,treeheight,Elevation,Canopy_cover,ridge) %>%
mutate(tree=scale(treeheight)[,1], elev=scale(Elevation)[,1],canopy=scale(Canopy_cover)[,1])
###############################################################################
############## CREATE OBSERVATION COVARIATE DATA INPUT MATRIX   ###############
###############################################################################
SURVEYDATA<-SURVEYDATA %>%
arrange(Point,Year,Count) %>%
mutate(time=scale(time),Day=scale(Day))
## SORT THE TABLE SO IT HAS THE SAME ORDER AS THE BIRD DATA
obsCov<-obsCov %>%
arrange(Point,Year,Count)
### only needs standardisation if measured in mm, not as 0/1 variable
#meant<-mean(SURVEYDATA$rain, na.rm = TRUE)
#sdt<-sd(SURVEYDATA$rain, na.rm = TRUE)
#SURVEYDATA$rain<-(SURVEYDATA$rain-meant)/sdt
### create array for each covariate
wind<-array(NA, dim=c(nsites,3,nyears))
time<-array(NA, dim=c(nsites,3,nyears))
ACT<-array(NA, dim=c(nsites,3,nyears))				## REPLACED ON 2 MAY WITH RAINFALL AMOUNT
### fill in array for each covariate
for (y in 2011:YEAR){
obsC<-subset(SURVEYDATA, Year==y)
y<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
x<-obsC %>% dplyr::select(Point, Count, time) %>% tidyr::spread(key=Count, value=time) %>% dplyr::arrange(Point)
time[,,y]<-as.matrix(x[,2:4])
x<-obsC %>% dplyr::select(Point, Count, wind) %>% tidyr::spread(key=Count, value=wind) %>% dplyr::arrange(Point)
wind[,,y]<-as.matrix(x[,2:4])
x<-obsC %>% dplyr::select(Point, Count, ACT) %>% tidyr::spread(key=Count, value=ACT) %>% dplyr::arrange(Point)
ACT[,,y]<-as.matrix(x[,2:4])
}
for (d in 1:nyears){							### replace missing dates with mean for each survey round in each year
ACT[is.na(ACT[,1,d]),1,d]<-mean(ACT[,1,d], na.rm=T)
ACT[is.na(ACT[,2,d]),2,d]<-mean(ACT[,2,d], na.rm=T)
ACT[is.na(ACT[,3,d]),3,d]<-mean(ACT[,3,d], na.rm=T)
time[is.na(time[,1,d]),1,d]<-mean(time[,1,d], na.rm=T)
time[is.na(time[,2,d]),2,d]<-mean(time[,2,d], na.rm=T)
time[is.na(time[,3,d]),3,d]<-mean(time[,3,d], na.rm=T)
wind[is.na(wind[,1,d]),1,d]<-0
wind[is.na(wind[,2,d]),2,d]<-0
wind[is.na(wind[,3,d]),3,d]<-0
}
# Specify model in NIMBLE format
trend.model<-nimbleCode({
####  Priors ########
loglam~dunif(-5,5)          ##  mean abundance prior
trend~dunif(-10,10)         ##  trend prior
beta.elev~dunif(-5,5)
beta.canopy~dunif(-5,5)
beta.treeheight~dunif(-5,5)
bwind~dunif(-5,5)
btime~dunif(-5,5)
bridge~dunif(-5,5)
bact~dunif(-5,5)
## SITE RANDOM EFFECT ##
for(i in 1:nsite){
lam.site[i]~dnorm(loglam,tau=tau.site)    ## site-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.site<-1/(sigma.site*sigma.site)
sigma.site~dunif(0,10)
## YEAR RANDOM EFFECT FOR ABUNDANCE AND ANNUALLY VARYING DETECTION PROBABILITY ##
for(year in 1:nyear){
p0[year]~dunif(0,1)## detection probability
logitp0[year]<-log(p0[year]/(1-p0[year]))
lam.year[year]~dnorm(trend*primocc[year],tau=tau.year)    ## year-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.lp<-1/(sigma.p*sigma.p)
sigma.p~dunif(0,10)
tau.year<-1/(sigma.year*sigma.year)
sigma.year~dunif(0,10)
######### State and observation models ##############
for(year in 1:nyear){
for(i in 1:nsite){
log(lambda[i,year])<- lam.year[year]+beta.rain*rain[year]+beta.elev*elev[i]+beta.treeheight*treeheight[i]+beta.canopy*canopy[i]+lam.site[i]
N[i,year]~dpois(lambda[i,year])
for(t in 1:nrep){
M[i,t,year]~dbin(p[i,t,year],N[i,year])
p[i,t,year] <- exp(lp[i,t,year])/(1+exp(lp[i,t,year]))
lp[i,t,year] ~ dnorm(mu.lp[i,t,year], tau=tau.lp)
mu.lp[i,t,year]<-logitp0[year] + btime*time[i,t,year]+ bridge*ridge[i]+ bwind*wind[i,t,year]+ bact*ACT[i,t,year]
}
}
### DERIVED PARAMETER FOR EACH YEAR ###
totalN[year]<-sum(N[1:nsite,year])
anndet[year]<-mean(p[1:nsite,1:nrep,year])
}
# Computation of fit statistic (Bayesian p-value)
# Fit statistic for observed data
# Also, generate replicate data and compute fit stats for them
for(year in 1:nyear){
for(i in 1:nsite){
for(t in 1:nrep){
# Actual data
eval[i,t,year] <-N[i,year]*p[i,t,year] # Expected value
sd.resi[i,t,year]<-sqrt(eval[i,t,year]*(1-p[i,t,year])) +0.5
E[i,t,year]<-(M[i,t,year]-eval[i,t,year])/ sd.resi[i,t,year]
E2[i,t,year] <- pow(E[i,t,year],2)
# Replicate data sets
M.new[i,t,year]~dbin(p[i,t,year],N[i,year])
E.new[i,t,year]<-(M.new[i,t,year]-eval[i,t,year])/sd.resi[i,t,year]
E2.new[i,t,year] <- pow(E.new[i,t,year], 2)
}
}
}
fit <- sum(E2[1:nsite,1:nrep,1:nyear])# Sum up squared residuals for actual data set
fit.new <- sum(E2.new[1:nsite,1:nrep,1:nyear]) # Sum up for replicate data sets
}) ## end of nimble code chunk
inits.trend <- list(N = Nst,
trend=0,
loglam = 0,
sigma.site = 2,
sigma.year=0,
sigma.p=0,
beta.canopy=0,
beta.rain=0,
beta.treeheight=0,
beta.elev=0,
bwind=0,
bridge=0,
btime=0,
bact=0,
p0 = runif(nyears,0,1))
# 5.3. Define parameters to be monitored
parameters.trend <- c("trend","totalN","fit", "fit.new","anndet")
# MCMC settings
# number of posterior samples per chain is n.iter - n.burnin
n.iter <- 50000
n.burnin <- 25000
n.chains <- 4
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
siteCov$ridge
wind
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
R = nrow(BIRD.y)
T = ncol(BIRD.y)
nyears = dim(BIRD.y)[3]
trend.constants <- list(nsite=dim(BIRD.y)[1],
nrep=ncol(BIRD.y),
primocc=seq(1:(dim(BIRD.y)[3])),
nyear=dim(BIRD.y)[3],
elev=siteCov$elev,
treeheight=siteCov$tree,
canopy=siteCov$canopy,
rain=rain$rain,
wind=wind,
ridge=siteCov$ridge,
time=time,
ACT=ACT)
trend.data <- list(M = BIRD.y)
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
test$calculate()
test$initializeInfo()
test$initializeInfo()
configureMCMC(test)
test$logProbs$anndet
test$logProbs
test@logProbs
str(test)
test
test$logProb_anndet
test$calculate(nodes="lam.site") # this causes a NaN when the nest probability (z[i] = 0)
test$logProb_lam.site
test$logProb_lam.site
test$logProb_lam.year
test$logProb_tau.lp
test$logProb_lambda
test$logProb_M
test$logProb_p
test$logProb_lambda
test$logProb_lam.site
inits.trend <- list(N = Nst,
trend=runif(1,-2,2),
loglam = runif(1,-2,2),
sigma.site = runif(1,0,2),
sigma.year=runif(1,-2,2),
sigma.p=runif(1,-2,2),
beta.canopy=runif(1,-2,2),
beta.rain=runif(1,-2,2),
beta.treeheight=runif(1,-2,2),
beta.elev=runif(1,-2,2),
bwind=runif(1,-2,2),
bridge=runif(1,-2,2),
btime=runif(1,-2,2),
bact=runif(1,-2,2),
p0 = runif(nyears,0,1))
# 5.3. Define parameters to be monitored
parameters.trend <- c("trend","totalN","fit", "fit.new","anndet")
# MCMC settings
# number of posterior samples per chain is n.iter - n.burnin
n.iter <- 50000
n.burnin <- 25000
n.chains <- 4
inits.trend <- list(inits.trend, inits.trend, inits.trend,inits.trend)
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
model$initializeInfo()
test$initializeInfo()
test$calculate(nodes="lam.site") # this causes a NaN when the nest probability (z[i] = 0)
test$logProb_lam.site
test$logProb_lam.year
test$logProb_tau.lp
test$logProb_tau.year
### make sure that none of the logProbs result in NA or -Inf as the model will not converge
test$calculate()
