######################################################################################
#############  START THE PARALLEL LOOP OVER EVERY SPECIES          ############################
######################################################################################
# trendout<-data.frame(species=SPECIES, timeframe=sprintf("2011-%i",YEAR), trend=0, lower95CI=-1, upper95CI=1, pval=0, slope=1)
# annestimates<-data.frame(species=rep(SPECIES, each=nyears), Year=seq(2011,YEAR), trend=0, lower95CI=-1, upper95CI=1, detprob=0, detproblower95CI=-1, detprobupper95CI=1)
#setup parallel backend to use 8 processors - collapsed my machine
cl<-makeCluster(4)
registerDoParallel(cl)
Result <- foreach(s=SPECIES, .packages=c('nimble',"tidyverse","MCMCvis","tidyverse","dplyr","data.table")) %dopar% {		#.combine = rbind,
# for (s in SPECIES){
# #s="MTOR"
######################################################################################
#############  TAKE SUBSET OF DATA FOR FOCAL SPECIES AND SORT THE TABLES    ###################
######################################################################################
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
# x<-bird_s %>%
#   mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
#   dplyr::filter(year==y) %>%
#   dplyr::select(Point, Count, N) %>%
#   tidyr::spread(key=Count, value=N) %>%
#   dplyr::arrange(Point)
# inits.new[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE ------------------------
#######################################################################################################
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.data <- list(M = BIRD.y)
####   ADD INITIAL VALUES----     ################################
## MUST ADD Nst TO INITIAL VALUESBE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
inits.trend$N = Nst
inits.trend$M = inits.y
#inits.trend$M.new = inits.new
allchaininits.trend <- list(inits.trend, inits.trend, inits.trend)
###############################################################################
####   RUN THE MODEL IN NIMBLE  --------------------###########################
###############################################################################
### this takes 14-15 mins for 50000 iterations and converges in that time
TRENDMOD <- nimbleMCMC(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = allchaininits.trend,
monitors = parameters.trend,
thin=4,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains,
progressBar = getNimbleOption("MCMCprogressBar"),
summary=T)
saveRDS(TRENDMOD,sprintf("output/%s_trend_model_nimble.rds"))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# EXAMINE OUTPUT AND DIAGNOSTICS WITH MCMCvis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
out<- as.data.frame(MCMCsummary(TRENDMOD$samples, params=c("trend","totalN","anndet")))
out$parameter<-row.names(out)
out$species<-s
names(out)[c(3,4,5)]<-c('lcl','median', 'ucl')
fwrite(out,sprintf("output/%s_trend_estimates.csv"))
# MCMCplot(TRENDMOD$samples, params=c("trend","totalN","anndet"))
# ggsave(sprintf("output/%s_trend_estimates.jpg"), height=9, width=9)
#
# ## look at the chains and whether they mixed well
# chainsPlot(TRENDMOD$samples,var=c("trend"))
# chainsPlot(TRENDMOD$samples,var=c("totalN"))
# chainsPlot(TRENDMOD$samples,var=c("anndet"))
###############################################################################
####   EVALUATE MODEL FIT WITH BAYESIAN P VALUE   #############################
###############################################################################
# ylow<-round((min(TRENDMOD$sims.list$fit)-50)/1000,1)*1000
# yup<-round((max(TRENDMOD$sims.list$fit)+50)/1000,1)*1000
# pdf(sprintf("MONTSERRAT_%s_model_fit2023.pdf",s), width=10, height=10, title="")
# plot(model$sims.list$fit, model$sims.list$fit.new, main = "", xlab = "Discrepancy actual data", ylab = "Discrepancy replicate data", frame.plot = FALSE, xlim = c(ylow, yup), ylim = c(ylow, yup))
# abline(0, 1, lwd = 2, col = "black")
# dev.off()
# pval<-mean(TRENDMOD$samples[[1]]$trend > TRENDMOD$samples$fit)
# slope<-mean(TRENDMOD$mean$fit) / mean(TRENDMOD$mean$fit.new)
#
# ###############################################################################
# ####   PRINT AND SAVE MODEL OUTPUT                #############################
# ###############################################################################
#
# # Summarize posteriors
# #print(model, dig = 3)
#
# write.table(model$summary,sprintf("%s_abund_estimates2023_p%f.csv",s,pval), sep=",")
#
#
# trendout[trendout$species==s,3]<-round(out[1,4],3)
# trendout[trendout$species==s,4]<-round(out[1,3],3)
# trendout[trendout$species==s,5]<-round(out[1,5],3)
# # trendout[trendout$species==s,6]<-pval
# # trendout[trendout$species==s,7]<-slope
#
# annestimates[annestimates$species==s,3]<-round(model$summary[2:(nyears+1),5],3)
# annestimates[annestimates$species==s,4]<-round(model$summary[2:(nyears+1),3],3)
# annestimates[annestimates$species==s,5]<-round(model$summary[2:(nyears+1),7],3)
# annestimates[annestimates$species==s,6]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),5],3)
# annestimates[annestimates$species==s,7]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),3],3)
# annestimates[annestimates$species==s,8]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),7],3)
#
# ###############################################################################
# ####   CREATE TREND PLOT AND SAVE AS PDF          #############################
# ###############################################################################
#
# trendlabel<- paste("Trend: ",trendout[trendout$species==s,3]," (",trendout[trendout$species==s,4]," - ",trendout[trendout$species==s,5],")", sep="")
# ggplot(annestimates[annestimates$species==s,], aes(x=Year,y=trend)) +
#   geom_line(colour="indianred", linewidth=1.5) +
#   geom_ribbon(aes(ymin = lower95CI, ymax = upper95CI), fill="indianred", alpha = 0.2) +
#
#   ## format axis ticks
#   scale_x_continuous(name="Year", breaks=seq(2011,2023,2), labels=as.character(seq(2011,2023,2)))+
#   #scale_y_continuous(name="Number of Birds at 67 Sampling Points", breaks=seq(0,4000,500), labels=as.character(seq(0,4000,500)))+
#   ylab(sprintf("Number of %s at %i sampling points",s,nsites)) +
#
#   annotate("text", x = -Inf, y = Inf, label = trendlabel, vjust = 2, hjust = -0.1,size=6, color="black") +
#
#   ## beautification of the axes
#   theme(panel.background=element_rect(fill="white", colour="black"), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.text=element_text(size=18, color="black"),
#         axis.title=element_text(size=18),
#         strip.text.x=element_text(size=18, color="black"),
#         axis.title.y=element_text(margin=margin(0,20,0,0)),
#         strip.background=element_rect(fill="white", colour="black"))
#
# ggsave(sprintf("MONTSERRAT_%s_abund_plot2023.pdf",s), width=12, height=9)
#
#
#
##### END THE LOOP ACROSS SPECIES ####
}
for (s in SPECIES){
# #s="MTOR"
######################################################################################
#############  TAKE SUBSET OF DATA FOR FOCAL SPECIES AND SORT THE TABLES    ###################
######################################################################################
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
# x<-bird_s %>%
#   mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
#   dplyr::filter(year==y) %>%
#   dplyr::select(Point, Count, N) %>%
#   tidyr::spread(key=Count, value=N) %>%
#   dplyr::arrange(Point)
# inits.new[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE ------------------------
#######################################################################################################
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.data <- list(M = BIRD.y)
####   ADD INITIAL VALUES----     ################################
## MUST ADD Nst TO INITIAL VALUESBE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
inits.trend$N = Nst
inits.trend$M = inits.y
#inits.trend$M.new = inits.new
allchaininits.trend <- list(inits.trend, inits.trend, inits.trend)
###############################################################################
####   RUN THE MODEL IN NIMBLE  --------------------###########################
###############################################################################
### this takes 14-15 mins for 50000 iterations and converges in that time
TRENDMOD <- nimbleMCMC(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = allchaininits.trend,
monitors = parameters.trend,
thin=4,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains,
progressBar = getNimbleOption("MCMCprogressBar"),
summary=T)
saveRDS(TRENDMOD,sprintf("output/%s_trend_model_nimble.rds"))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# EXAMINE OUTPUT AND DIAGNOSTICS WITH MCMCvis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
out<- as.data.frame(MCMCsummary(TRENDMOD$samples, params=c("trend","totalN","anndet")))
out$parameter<-row.names(out)
out$species<-s
names(out)[c(3,4,5)]<-c('lcl','median', 'ucl')
fwrite(out,sprintf("output/%s_trend_estimates.csv"))
# MCMCplot(TRENDMOD$samples, params=c("trend","totalN","anndet"))
# ggsave(sprintf("output/%s_trend_estimates.jpg"), height=9, width=9)
#
# ## look at the chains and whether they mixed well
# chainsPlot(TRENDMOD$samples,var=c("trend"))
# chainsPlot(TRENDMOD$samples,var=c("totalN"))
# chainsPlot(TRENDMOD$samples,var=c("anndet"))
###############################################################################
####   EVALUATE MODEL FIT WITH BAYESIAN P VALUE   #############################
###############################################################################
# ylow<-round((min(TRENDMOD$sims.list$fit)-50)/1000,1)*1000
# yup<-round((max(TRENDMOD$sims.list$fit)+50)/1000,1)*1000
# pdf(sprintf("MONTSERRAT_%s_model_fit2023.pdf",s), width=10, height=10, title="")
# plot(model$sims.list$fit, model$sims.list$fit.new, main = "", xlab = "Discrepancy actual data", ylab = "Discrepancy replicate data", frame.plot = FALSE, xlim = c(ylow, yup), ylim = c(ylow, yup))
# abline(0, 1, lwd = 2, col = "black")
# dev.off()
# pval<-mean(TRENDMOD$samples[[1]]$trend > TRENDMOD$samples$fit)
# slope<-mean(TRENDMOD$mean$fit) / mean(TRENDMOD$mean$fit.new)
#
# ###############################################################################
# ####   PRINT AND SAVE MODEL OUTPUT                #############################
# ###############################################################################
#
# # Summarize posteriors
# #print(model, dig = 3)
#
# write.table(model$summary,sprintf("%s_abund_estimates2023_p%f.csv",s,pval), sep=",")
#
#
# trendout[trendout$species==s,3]<-round(out[1,4],3)
# trendout[trendout$species==s,4]<-round(out[1,3],3)
# trendout[trendout$species==s,5]<-round(out[1,5],3)
# # trendout[trendout$species==s,6]<-pval
# # trendout[trendout$species==s,7]<-slope
#
# annestimates[annestimates$species==s,3]<-round(model$summary[2:(nyears+1),5],3)
# annestimates[annestimates$species==s,4]<-round(model$summary[2:(nyears+1),3],3)
# annestimates[annestimates$species==s,5]<-round(model$summary[2:(nyears+1),7],3)
# annestimates[annestimates$species==s,6]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),5],3)
# annestimates[annestimates$species==s,7]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),3],3)
# annestimates[annestimates$species==s,8]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),7],3)
#
# ###############################################################################
# ####   CREATE TREND PLOT AND SAVE AS PDF          #############################
# ###############################################################################
#
# trendlabel<- paste("Trend: ",trendout[trendout$species==s,3]," (",trendout[trendout$species==s,4]," - ",trendout[trendout$species==s,5],")", sep="")
# ggplot(annestimates[annestimates$species==s,], aes(x=Year,y=trend)) +
#   geom_line(colour="indianred", linewidth=1.5) +
#   geom_ribbon(aes(ymin = lower95CI, ymax = upper95CI), fill="indianred", alpha = 0.2) +
#
#   ## format axis ticks
#   scale_x_continuous(name="Year", breaks=seq(2011,2023,2), labels=as.character(seq(2011,2023,2)))+
#   #scale_y_continuous(name="Number of Birds at 67 Sampling Points", breaks=seq(0,4000,500), labels=as.character(seq(0,4000,500)))+
#   ylab(sprintf("Number of %s at %i sampling points",s,nsites)) +
#
#   annotate("text", x = -Inf, y = Inf, label = trendlabel, vjust = 2, hjust = -0.1,size=6, color="black") +
#
#   ## beautification of the axes
#   theme(panel.background=element_rect(fill="white", colour="black"), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.text=element_text(size=18, color="black"),
#         axis.title=element_text(size=18),
#         strip.text.x=element_text(size=18, color="black"),
#         axis.title.y=element_text(margin=margin(0,20,0,0)),
#         strip.background=element_rect(fill="white", colour="black"))
#
# ggsave(sprintf("MONTSERRAT_%s_abund_plot2023.pdf",s), width=12, height=9)
#
#
#
##### END THE LOOP ACROSS SPECIES ####
}
saveRDS(TRENDMOD,sprintf("output/%s_trend_model_nimble.rds",s))
fwrite(out,sprintf("output/%s_trend_estimates.csv",s))
out<- as.data.frame(MCMCsummary(TRENDMOD$samples, params=c("trend","totalN","anndet")))
out$parameter<-row.names(out)
out$species<-s
names(out)[c(3,4,5)]<-c('lcl','median', 'ucl')
fwrite(out,sprintf("output/%s_trend_estimates.csv",s))
#setup parallel backend to use 8 processors - collapsed my machine
cl<-makeCluster(4)
registerDoParallel(cl)
Result <- foreach(s=SPECIES, .packages=c('nimble',"tidyverse","MCMCvis","tidyverse","dplyr","data.table")) %dopar% {		#.combine = rbind,
# for (s in SPECIES){
# #s="MTOR"
######################################################################################
#############  TAKE SUBSET OF DATA FOR FOCAL SPECIES AND SORT THE TABLES    ###################
######################################################################################
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
# x<-bird_s %>%
#   mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
#   dplyr::filter(year==y) %>%
#   dplyr::select(Point, Count, N) %>%
#   tidyr::spread(key=Count, value=N) %>%
#   dplyr::arrange(Point)
# inits.new[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE ------------------------
#######################################################################################################
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.data <- list(M = BIRD.y)
####   ADD INITIAL VALUES----     ################################
## MUST ADD Nst TO INITIAL VALUESBE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
inits.trend$N = Nst
inits.trend$M = inits.y
#inits.trend$M.new = inits.new
allchaininits.trend <- list(inits.trend, inits.trend, inits.trend)
###############################################################################
####   RUN THE MODEL IN NIMBLE  --------------------###########################
###############################################################################
### this takes 14-15 mins for 50000 iterations and converges in that time
TRENDMOD <- nimbleMCMC(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = allchaininits.trend,
monitors = parameters.trend,
thin=4,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains,
progressBar = getNimbleOption("MCMCprogressBar"),
summary=T)
saveRDS(TRENDMOD,sprintf("output/%s_trend_model_nimble.rds",s))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# EXAMINE OUTPUT AND DIAGNOSTICS WITH MCMCvis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
out<- as.data.frame(MCMCsummary(TRENDMOD$samples, params=c("trend","totalN","anndet")))
out$parameter<-row.names(out)
out$species<-s
names(out)[c(3,4,5)]<-c('lcl','median', 'ucl')
fwrite(out,sprintf("output/%s_trend_estimates.csv",s))
# MCMCplot(TRENDMOD$samples, params=c("trend","totalN","anndet"))
# ggsave(sprintf("output/%s_trend_estimates.jpg"), height=9, width=9)
#
# ## look at the chains and whether they mixed well
# chainsPlot(TRENDMOD$samples,var=c("trend"))
# chainsPlot(TRENDMOD$samples,var=c("totalN"))
# chainsPlot(TRENDMOD$samples,var=c("anndet"))
###############################################################################
####   EVALUATE MODEL FIT WITH BAYESIAN P VALUE   #############################
###############################################################################
# ylow<-round((min(TRENDMOD$sims.list$fit)-50)/1000,1)*1000
# yup<-round((max(TRENDMOD$sims.list$fit)+50)/1000,1)*1000
# pdf(sprintf("MONTSERRAT_%s_model_fit2023.pdf",s), width=10, height=10, title="")
# plot(model$sims.list$fit, model$sims.list$fit.new, main = "", xlab = "Discrepancy actual data", ylab = "Discrepancy replicate data", frame.plot = FALSE, xlim = c(ylow, yup), ylim = c(ylow, yup))
# abline(0, 1, lwd = 2, col = "black")
# dev.off()
# pval<-mean(TRENDMOD$samples[[1]]$trend > TRENDMOD$samples$fit)
# slope<-mean(TRENDMOD$mean$fit) / mean(TRENDMOD$mean$fit.new)
#
# ###############################################################################
# ####   PRINT AND SAVE MODEL OUTPUT                #############################
# ###############################################################################
#
# # Summarize posteriors
# #print(model, dig = 3)
#
# write.table(model$summary,sprintf("%s_abund_estimates2023_p%f.csv",s,pval), sep=",")
#
#
# trendout[trendout$species==s,3]<-round(out[1,4],3)
# trendout[trendout$species==s,4]<-round(out[1,3],3)
# trendout[trendout$species==s,5]<-round(out[1,5],3)
# # trendout[trendout$species==s,6]<-pval
# # trendout[trendout$species==s,7]<-slope
#
# annestimates[annestimates$species==s,3]<-round(model$summary[2:(nyears+1),5],3)
# annestimates[annestimates$species==s,4]<-round(model$summary[2:(nyears+1),3],3)
# annestimates[annestimates$species==s,5]<-round(model$summary[2:(nyears+1),7],3)
# annestimates[annestimates$species==s,6]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),5],3)
# annestimates[annestimates$species==s,7]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),3],3)
# annestimates[annestimates$species==s,8]<-round(model$summary[(nyears+4):(dim(model$summary)[1]-1),7],3)
#
# ###############################################################################
# ####   CREATE TREND PLOT AND SAVE AS PDF          #############################
# ###############################################################################
#
# trendlabel<- paste("Trend: ",trendout[trendout$species==s,3]," (",trendout[trendout$species==s,4]," - ",trendout[trendout$species==s,5],")", sep="")
# ggplot(annestimates[annestimates$species==s,], aes(x=Year,y=trend)) +
#   geom_line(colour="indianred", linewidth=1.5) +
#   geom_ribbon(aes(ymin = lower95CI, ymax = upper95CI), fill="indianred", alpha = 0.2) +
#
#   ## format axis ticks
#   scale_x_continuous(name="Year", breaks=seq(2011,2023,2), labels=as.character(seq(2011,2023,2)))+
#   #scale_y_continuous(name="Number of Birds at 67 Sampling Points", breaks=seq(0,4000,500), labels=as.character(seq(0,4000,500)))+
#   ylab(sprintf("Number of %s at %i sampling points",s,nsites)) +
#
#   annotate("text", x = -Inf, y = Inf, label = trendlabel, vjust = 2, hjust = -0.1,size=6, color="black") +
#
#   ## beautification of the axes
#   theme(panel.background=element_rect(fill="white", colour="black"), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
#         axis.text=element_text(size=18, color="black"),
#         axis.title=element_text(size=18),
#         strip.text.x=element_text(size=18, color="black"),
#         axis.title.y=element_text(margin=margin(0,20,0,0)),
#         strip.background=element_rect(fill="white", colour="black"))
#
# ggsave(sprintf("MONTSERRAT_%s_abund_plot2023.pdf",s), width=12, height=9)
#
#
#
##### END THE LOOP ACROSS SPECIES ####
}
