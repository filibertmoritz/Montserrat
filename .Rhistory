E2[i,t,year] <- pow(E[i,t,year],2)
# Replicate data sets
M.new[i,t,year]~dbin(p[i,t,year],N[i,year])
E.new[i,t,year]<-(M.new[i,t,year]-eval[i,t,year])/sd.resi[i,t,year]
E2.new[i,t,year] <- pow(E.new[i,t,year], 2)
}
}
}
fit <- sum(E2[1:nsite,1:nrep,1:nyear])# Sum up squared residuals for actual data set
fit.new <- sum(E2.new[1:nsite,1:nrep,1:nyear]) # Sum up for replicate data sets
}) ## end of nimble code chunk
trend.constants <- list(nsite=nsites,
nrep=3,
primocc=seq(2011:YEAR),
nyear=nyears,
elev=siteCov$elev,
treeheight=siteCov$tree,
canopy=siteCov$canopy,
rain=rain$rain,
wind=wind,
day=day,
ridge=siteCov$ridge,
time=time,
ACT=ACT)
####   DEFINE INITIAL VALUES----     ################################
## MUST BE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend <- list(N = Nst,
trend=runif(1,-2,2),
loglam = runif(1,-2,2),
sigma.site = runif(1,0,2),
sigma.year=runif(1,0,2),
sigma.p=runif(1,0,2),
beta.canopy=runif(1,-2,2),
beta.rain=runif(1,-2,2),
beta.treeheight=runif(1,-2,2),
beta.elev=runif(1,-2,2),
bwind=-1,
bridge=-1,
btime=-1,
bday=1,
bact=2,
p0 = runif(nyears,0.1,0.9))
inits.trend$lam.site<-rnorm(nsites,inits.trend$loglam,inits.trend$sigma.site)
inits.trend$lam.year<-rnorm(nyears,(inits.trend$trend*seq(1:(dim(BIRD.y)[3]))),inits.trend$sigma.year)
####   DEFINE RUN SETTINGS AND OUTPUT DATA----     ################################
# Define parameters to be monitored
parameters.trend <- c("trend","totalN","anndet")  #"fit", "fit.new",
# MCMC settings
# number of posterior samples per chain is n.iter - n.burnin
n.iter <- 5000
n.burnin <- 3000
n.chains <- 3
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
c(test$mu.lp)
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
s="MTOR"
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
y<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,y]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,y]<-as.matrix(x[,2:4])
}
y
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
y<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,y]<-as.matrix(x[,2:4])
x
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
bird_s
y
y=2011
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.new[,,yc]<-as.matrix(x[,2:4])
}
#for (s in SPECIES){
s="MTOR"
######################################################################################
#############  TAKE SUBSET OF DATA FOR FOCAL SPECIES AND SORT THE TABLES    ###################
######################################################################################
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.new[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE ------------------------
#######################################################################################################
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.data <- list(M = BIRD.y)
####   ADD INITIAL VALUES----     ################################
## MUST ADD Nst TO INITIAL VALUESBE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
inits.trend$N = Nst
inits.trend$M = inits.y
inits.trend$M.new = inits.new
allchaininits.trend <- list(inits.trend, inits.trend, inits.trend)
TRENDMOD <- nimbleMCMC(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = allchaininits.trend,
monitors = parameters.trend,
thin=4,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains,
progressBar = getNimbleOption("MCMCprogressBar"),
summary=T)
######################################################################################
#############  WRITE THE NIMBLE MODEL AND SET INITS  ############################
######################################################################################
# Specify model in NIMBLE format
trend.model<-nimbleCode({
####  Priors ########
loglam~dunif(-5,5)          ##  mean abundance prior
trend~dunif(-5,5)         ##  trend prior
beta.elev~dunif(-2,2)
beta.rain~dunif(-2,2)
beta.canopy~dunif(-2,2)
beta.treeheight~dunif(-2,2)
bwind~dunif(-2,2)
btime~dunif(-2,2)
bday~dunif(-2,2)
bridge~dunif(-2,2)
bact~dunif(-2,2)
## SITE RANDOM EFFECT ##
for(i in 1:nsite){
lam.site[i]~dnorm(loglam,tau=tau.site)    ## site-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.site<-1/(sigma.site*sigma.site)
sigma.site~dunif(0,10)
## YEAR RANDOM EFFECT FOR ABUNDANCE AND ANNUALLY VARYING DETECTION PROBABILITY ##
for(year in 1:nyear){
p0[year]~dunif(0.01,0.99)## detection probability
logitp0[year]<-log(p0[year]/(1-p0[year]))
lam.year[year]~dnorm(trend*primocc[year],tau=tau.year)    ## year-specific random effect with hierarchical centering from Kery email 5 June 2018
}
tau.lp<-1/(sigma.p*sigma.p)
sigma.p~dunif(0,10)
tau.year<-1/(sigma.year*sigma.year)
sigma.year~dunif(0,10)
######### State and observation models ##############
for(year in 1:nyear){
for(i in 1:nsite){
log(lambda[i,year])<- lam.year[year]+
beta.rain*rain[year]+
beta.elev*elev[i]+
beta.treeheight*treeheight[i]+
beta.canopy*canopy[i]+
lam.site[i]
N[i,year]~dpois(lambda[i,year])
for(t in 1:nrep){
M[i,t,year]~dbin(p[i,t,year],N[i,year])
p[i,t,year] <- exp(lp[i,t,year])/(1+exp(lp[i,t,year]))
lp[i,t,year] ~ dnorm(mu.lp[i,t,year], tau=tau.lp)
mu.lp[i,t,year]<-logitp0[year] +
btime*time[i,t,year]+
bday*day[i,t,year]+
bridge*ridge[i]+
bwind*wind[i,t,year]+
bact*ACT[i,t,year]
}
}
### DERIVED PARAMETER FOR EACH YEAR ###
totalN[year]<-sum(N[1:nsite,year])
anndet[year]<-mean(p[1:nsite,1:nrep,year])
}
# # Computation of fit statistic (Bayesian p-value)
# # Fit statistic for observed data
# # Also, generate replicate data and compute fit stats for them
# for(year in 1:nyear){
#   for(i in 1:nsite){
#     for(t in 1:nrep){
#
#       # Actual data
#       eval[i,t,year] <-N[i,year]*p[i,t,year] # Expected value
#       sd.resi[i,t,year]<-sqrt(eval[i,t,year]*(1-p[i,t,year])) +0.5
#       E[i,t,year]<-(M[i,t,year]-eval[i,t,year])/ sd.resi[i,t,year]
#       E2[i,t,year] <- pow(E[i,t,year],2)
#
#       # Replicate data sets
#       M.new[i,t,year]~dbin(p[i,t,year],N[i,year])
#       E.new[i,t,year]<-(M.new[i,t,year]-eval[i,t,year])/sd.resi[i,t,year]
#       E2.new[i,t,year] <- pow(E.new[i,t,year], 2)
#     }
#   }
# }
# fit <- sum(E2[1:nsite,1:nrep,1:nyear])# Sum up squared residuals for actual data set
# fit.new <- sum(E2.new[1:nsite,1:nrep,1:nyear]) # Sum up for replicate data sets
}) ## end of nimble code chunk
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE - GENERIC PART     -----------------------
#######################################################################################################
#### data and inits that will be the same for all species
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.constants <- list(nsite=nsites,
nrep=3,
primocc=seq(2011:YEAR),
nyear=nyears,
elev=siteCov$elev,
treeheight=siteCov$tree,
canopy=siteCov$canopy,
rain=rain$rain,
wind=wind,
day=day,
ridge=siteCov$ridge,
time=time,
ACT=ACT)
####   DEFINE INITIAL VALUES----     ################################
## MUST BE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend <- list(N = Nst,
trend=runif(1,-2,2),
loglam = runif(1,-2,2),
sigma.site = runif(1,0,2),
sigma.year=runif(1,0,2),
sigma.p=runif(1,0,2),
beta.canopy=runif(1,-2,2),
beta.rain=runif(1,-2,2),
beta.treeheight=runif(1,-2,2),
beta.elev=runif(1,-2,2),
bwind=-1,
bridge=-1,
btime=-1,
bday=1,
bact=2,
p0 = runif(nyears,0.1,0.9))
inits.trend$lam.site<-rnorm(nsites,inits.trend$loglam,inits.trend$sigma.site)
inits.trend$lam.year<-rnorm(nyears,(inits.trend$trend*seq(1:(dim(BIRD.y)[3]))),inits.trend$sigma.year)
####   DEFINE RUN SETTINGS AND OUTPUT DATA----     ################################
# Define parameters to be monitored
parameters.trend <- c("trend","totalN","anndet")  #"fit", "fit.new",
# MCMC settings
# number of posterior samples per chain is n.iter - n.burnin
n.iter <- 5000
n.burnin <- 3000
n.chains <- 3
# PRELIMINARY TEST OF NIMBLE MODEL TO IDENTIFY PROBLEMS --------------------
test <- nimbleModel(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = inits.trend,
calculate=TRUE)
# USE TEST VALUES TO SUPPLEMENT INITS
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
# inits.trend$p0
# test$initializeInfo()
#
# # Missing values (NAs) or non-finite values were found in model variables:
# # M, p, lp, anndet,
# # E, E2, M.new, E.new, E2.new, fit, fit.new.
#
# ### make sure that none of the logProbs result in NA or -Inf as the model will not converge
# test$calculate()
# is.na(trend.constants) ## check whether there are NA in the data
# test$calculate(nodes="lam.site") # this seems to be ok
# test$logProb_lam.site
# test$logProb_lam.year
# test$logProb_p0
# log(test$logProb_p0/(1-test$logProb_p0))
# test$logProb_btime
# test$logProb_bday
# test$logProb_bridge
# test$logProb_bact
# test$logProb_M  # this is NA for all values
# test$logProb_lp  # this is NA for all values
# test$logProb_p  # this is NA for all values
# test$initializeInfo()
# #help(modelInitialization)
#
# ### make sure that none of the logProbs result in NA or -Inf as the model will not converge
# configureMCMC(test) # check that the samplers used are ok - all RW samplers need proper inits
######################################################################################
#############  START THE LOOP OVER EVERY SPECIES          ############################
######################################################################################
trendout<-data.frame(species=SPECIES, timeframe=sprintf("2011-%i",YEAR), trend=0, lower95CI=-1, upper95CI=1, pval=0, slope=1)
annestimates<-data.frame(species=rep(SPECIES, each=nyears), Year=seq(2011,YEAR), trend=0, lower95CI=-1, upper95CI=1, detprob=0, detproblower95CI=-1, detprobupper95CI=1)
#for (s in SPECIES){
s="MTOR"
######################################################################################
#############  TAKE SUBSET OF DATA FOR FOCAL SPECIES AND SORT THE TABLES    ###################
######################################################################################
bird_s<-SURVEYDATA[,c(1,2,3,4,match(s,colnames(SURVEYDATA)))] %>%
arrange(Point,year,Count) %>%
rename(N=5) %>%
mutate(N=if_else(is.na(VisitID),NA,N)) %>%  ### RE-INTRODUCE THE NAs for COUNTS THAT DID NOT TAKE PLACE #####
dplyr::select(Point,year,Count,N)
###############################################################################
############## CREATE BIRD DATA INPUT MATRIX   ################################
###############################################################################
#### FILL THE MISSING DATA WITH MEAN VALUES FOR INITS
## https://groups.google.com/g/nimble-users/c/wCwacQPLR2w?pli=1
### create array to be filled with data
BIRD.y<-array(NA, dim=c(nsites,3,nyears))
inits.y<-array(NA, dim=c(nsites,3,nyears))
inits.new<-array(NA, dim=c(nsites,3,nyears))
### fill in array for bird data and initial values
for (y in 2011:YEAR){
x<-bird_s %>%
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
yc<-match(y,c(2011:YEAR))						## translates the year (2011, 2012, etc.) into consecutive number (1,2,...) for array dimensions
BIRD.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),NA)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.y[,,yc]<-as.matrix(x[,2:4])
x<-bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values
dplyr::filter(year==y) %>%
dplyr::select(Point, Count, N) %>%
tidyr::spread(key=Count, value=N) %>%
dplyr::arrange(Point)
inits.new[,,yc]<-as.matrix(x[,2:4])
}
#### GET THE MAXIMUM COUNT PER POINT PER YEAR FOR INITIAL VALUES
Nst<-as.matrix(bird_s %>%
mutate(N=ifelse(is.na(N),median(bird_s$N, na.rm=T),N)) %>%   ### fill in missing values - switch to max if there is invalid parent error
group_by(Point, year) %>%
summarise(K=max(N, na.rm=T)) %>%
spread(key=year,value=K, fill=max(bird_s$N,na.rm=T)) %>%
ungroup() %>%
arrange(Point) %>%
dplyr::select(-Point))
######################################################################################################
########## CREATE INPUT DATA FOR NIMBLE ------------------------
#######################################################################################################
#### DISTINGUISH CONSTANTS AND DATA
# Constants are values that do not change, e.g. vectors of known index values or the indices used to define for loops
# Data are values that you might want to change, basically anything that only appears on the left of a ~
trend.data <- list(M = BIRD.y)
####   ADD INITIAL VALUES----     ################################
## MUST ADD Nst TO INITIAL VALUESBE FOR ALL PARAMETERS
## NIMBLE CAN HAVE CONVERGENCE PROBLEMS IF DIFFERENT INITS ARE SPECIFIED: https://groups.google.com/g/nimble-users/c/dgx9ajOniG8
inits.trend$lp = array(rnorm(trend.constants$nsite*trend.constants$nrep*trend.constants$nyear, c(test$mu.lp), inits.trend$sigma.p),
dim= c(trend.constants$nsite, trend.constants$nrep,trend.constants$nyear))
inits.trend$N = Nst
inits.trend$M = inits.y
inits.trend$M.new = inits.new
allchaininits.trend <- list(inits.trend, inits.trend, inits.trend)
###############################################################################
####   RUN THE MODEL IN NIMBLE  --------------------###########################
###############################################################################
### this takes 14-15 mins for 50000 iterations and converges in that time
TRENDMOD <- nimbleMCMC(code = trend.model,
constants=trend.constants,
data = trend.data,
inits = allchaininits.trend,
monitors = parameters.trend,
thin=4,
niter = n.iter,
nburnin = n.burnin,
nchains = n.chains,
progressBar = getNimbleOption("MCMCprogressBar"),
summary=T)
TRENDMOD
out<- as.data.frame(MCMCsummary(TRENDMOD$samples, params=c("trend","totalN","anndet")))
out$parameter<-row.names(out)
out$species<-s
names(out)[c(3,4,5)]<-c('lcl','median', 'ucl')
out
trendout
annestimates
?MCMCsummary
